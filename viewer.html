<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D MRMS Point Cloud Viewer</title>
  <link href='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css' rel='stylesheet' />
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #main-container {
      display: flex;
      width: 100%;
      height: 100%;
    }
    #threeContainer, #mapContainer {
      width: 50%;
      height: 100%;
    }
    #threeContainer {
      position: relative; /* Needed for positioning children */
    }
    #tooltip {
      position: absolute;
      display: none;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      border-radius: 5px;
      font-family: sans-serif;
      pointer-events: none; /* So it doesn't block mouse events */
      z-index: 10;
    }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      border-radius: 5px;
      font-family: sans-serif;
      display: none; /* Hidden by default */
      z-index: 10;
    }
    .annotation-label {
      position: absolute;
      padding: 5px 10px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 5px;
      font-family: sans-serif;
      font-size: 14px;
      pointer-events: none;
      transform: translate(-50%, -120%); /* Position above the center point */
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="main-container">
  <div id="threeContainer">
    <div id="tooltip"></div>
    <div id="instructions"></div>
    <div id="labels-container"></div>
  </div>
  <div id="mapContainer"></div>
</div>

<script src='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js'></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
<script>
  // --- Global Variables ---
  let allPoints = [];
  let metadata = {}; // <-- Will hold our radar metadata
  let map; // <-- Will hold the map object
  let nextAnnotationId = 0; // Simple ID generator for map features
  let controls; // <-- Make controls globally accessible
  let pointCloud;
  let gridHelper;
  
  // --- Core Scene Setup ---
  const threeContainer = document.getElementById('threeContainer');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 10000);
  camera.position.set(0, 0, 500);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
  threeContainer.appendChild(renderer.domElement);
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  gridHelper = new THREE.GridHelper(1000, 20);
  scene.add(gridHelper);

  // --- GUI Setup ---
  const gui = new lil.GUI({ container: threeContainer });
  const params = {
    pointSize: 2,
    opacity: 1.0,
    color: 0xffffff,
    startAnnotation: startAnnotation,
    saveAnnotations: saveAnnotations,
  };
  gui.add(params, 'pointSize', 0.1, 10).onChange(value => {
    material.size = value;
  });
  gui.add(params, 'opacity', 0, 1).onChange(value => {
    material.opacity = value;
  });
  gui.addColor(params, 'color').onChange(value => {
    material.color.set(value);
    material.vertexColors = false;
  });
  gui.add(params, 'startAnnotation').name('Start Annotation');
  gui.add(params, 'saveAnnotations').name('Save Annotations');

  const editFolder = gui.addFolder('Edit Annotation');
  const editParams = { description: '', delete: deleteSelectedAnnotation };
  const descriptionController = editFolder.add(editParams, 'description').name('Description');
  descriptionController.onChange(value => {
    if (selectedAnnotation) {
      selectedAnnotation.description = value;
      selectedAnnotation.labelElement.textContent = value;
    }
  });
  editFolder.add(editParams, 'delete').name('Delete Selected');
  editFolder.hide();

  // --- Point Inspection & Annotation Setup ---
  const raycaster = new THREE.Raycaster();
  raycaster.params.Points.threshold = 3;
  const mouse = new THREE.Vector2();
  const tooltip = document.getElementById('tooltip');
  const highlightGeo = new THREE.SphereGeometry(5);
  const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const highlightMarker = new THREE.Mesh(highlightGeo, highlightMat);
  highlightMarker.visible = false;
  scene.add(highlightMarker);

  let annotationState = 'idle';
  let corner1 = new THREE.Vector3();
  let currentBBoxHelper = null;
  const annotations = [];
  const annotationHitboxes = [];
  const instructions = document.getElementById('instructions');
  const labelsContainer = document.getElementById('labels-container');
  let selectedAnnotation = null;

  // --- NEW: Mapbox Viewer Initialization ---
  mapboxgl.accessToken = 'pk.eyJ1IjoiYWNvb2xhMDA4IiwiYSI6ImNtYzVzaWg3NjBza2sybnB0M3BlaGk3N28ifQ.MQcLcmFS08WyzBqo5HdUEg';
  map = new mapboxgl.Map({
    container: 'mapContainer',
    style: 'mapbox://styles/mapbox/satellite-streets-v12', // Satellite with labels
    center: [116.4074, 39.9042], // Beijing
    zoom: 6
  });

  // --- Utility Functions ---
  function toLonLat(x, y) {
    if (!metadata.radar_info) return null;

    const { lon: baseLon, lat: baseLat } = metadata.radar_info.location;
    const { x_dim, y_dim, pixel_size_km } = metadata.radar_info.properties;

    // Calculate distance from the center in kilometers
    const dx = (x - x_dim / 2) * pixel_size_km;
    const dy = (y - y_dim / 2) * pixel_size_km;

    // Earth radius in kilometers
    const R = 6378.137;

    // Calculate new latitude
    const newLat = baseLat + (dy / R) * (180 / Math.PI);
    // Calculate new longitude
    const newLon = baseLon + (dx / R) * (180 / Math.PI) / Math.cos(baseLat * Math.PI / 180);

    return { lon: newLon, lat: newLat };
  }

  // --- Main Data Loading & Map Setup ---
  map.on('load', () => {
    // Add source and layer for all annotations
    map.addSource('annotations', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });
    map.addLayer({
      id: 'annotations-layer',
      type: 'fill',
      source: 'annotations',
      paint: {
        'fill-color': [
          'case',
          ['boolean', ['feature-state', 'selected'], false],
          '#ff00ff', // Magenta when selected
          '#00ff00'  // Green otherwise
        ],
        'fill-opacity': 0.5
      }
    });
    
    Promise.all([
      fetch('mrms_point_cloud.json').then(res => res.json()),
      fetch('metadata/metadata.yml').then(res => res.text()).then(text => jsyaml.load(text))
    ]).then(([points, md]) => {
      allPoints = points;
      metadata = md;
      
      const geometry = new THREE.BufferGeometry();
      if (Array.isArray(points) && points.length > 0) {
        const positions = [];
        points.forEach(p => positions.push(p.x, p.y, p.z));
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      } else {
        console.error('Point cloud JSON is empty or not an array.');
      }
      const material = new THREE.PointsMaterial({
        size: params.pointSize,
        color: new THREE.Color(params.pointColor),
        transparent: true,
        opacity: params.opacity,
        vertexColors: false
      });
      pointCloud = new THREE.Points(geometry, material);
      scene.add(pointCloud);

      // Draw main data footprint on the map, only if the data is valid
      const { minLon, minLat, maxLon, maxLat } = calculateGeoBboxFromPoints(points);
      if (isFinite(minLon) && isFinite(minLat) && isFinite(maxLon) && isFinite(maxLat)) {
        map.addSource('footprint', {
          type: 'geojson',
          data: createGeoJsonPolygon(minLon, minLat, maxLon, maxLat)
        });
        map.addLayer({
          id: 'footprint-layer',
          type: 'line',
          source: 'footprint',
          paint: { 'line-color': '#ffffff', 'line-width': 2 }
        });
        map.fitBounds([[minLon, minLat], [maxLon, maxLat]], { padding: 40 });
      }

    }).catch(error => {
      console.error('Error loading data:', error);
      document.body.innerHTML = '<h2>Error loading data. Check console for details.</h2>';
    });
  });

  function calculateGeoBboxFromPoints(points) {
    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;
    points.forEach(p => {
      const coords = toLonLat(p.x, p.y);
      if(coords) {
        const { lon, lat } = coords;
        if (lon < minLon) minLon = lon;
        if (lat < minLat) minLat = lat;
        if (lon > maxLon) maxLon = lon;
        if (lat > maxLat) maxLat = lat;
      }
    });
    return { minLon, minLat, maxLon, maxLat };
  }

  function createGeoJsonPolygon(minLon, minLat, maxLon, maxLat, id, properties) {
    const feature = {
      type: 'Feature',
      id: id, // ID for feature state
      properties: properties || {},
      geometry: {
        type: 'Polygon',
        coordinates: [
          [
            [minLon, minLat],
            [minLon, maxLat],
            [maxLon, maxLat],
            [maxLon, minLat],
            [minLon, minLat]
          ]
        ]
      }
    };
    return feature;
  }

  // --- Core Application Functions (Annotation, Selection, etc.) ---
  function startAnnotation() {
    annotationState = 'placing_corner_1';
    controls.enabled = false;
    instructions.style.display = 'block';
    instructions.innerHTML = 'Click to place the first corner. Press <b>Delete</b> to remove the last annotation.';
  }

  function onPointerMove(event) {
    const rect = threeContainer.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);

    if (pointCloud) {
      const intersects = raycaster.intersectObject(pointCloud);
      if (intersects.length > 0) {
        const intersection = intersects[0];
        const pointData = allPoints[intersection.index];
        highlightMarker.position.copy(intersection.point);
        highlightMarker.visible = true;

        if (annotationState === 'idle') {
          // Update tooltip when not annotating
          tooltip.style.display = 'block';
          tooltip.style.left = event.clientX + 10 + 'px';
          tooltip.style.top = event.clientY + 10 + 'px';
          
          let tooltipContent = `
            <b>Point Info</b><br>
            X: ${pointData.x.toFixed(2)}<br>
            Y: ${pointData.y.toFixed(2)}<br>
            Z: ${pointData.z.toFixed(2)}<br>
            Reflectivity: ${pointData.reflectivity.toFixed(2)} dBZ
          `;

          // Check if point is inside any annotation and add descriptions
          annotations.forEach(anno => {
            if (anno.box.containsPoint(intersection.point)) {
              tooltipContent += `<hr><b>Annotation:</b> ${anno.description}`;
            }
          });
          tooltip.innerHTML = tooltipContent;

        } else if (annotationState === 'placing_corner_2') {
           // Update the bounding box helper in real-time
           const corner2 = intersection.point;
           currentBBoxHelper.box.setFromPoints([corner1, corner2]);
        }
      } else {
        tooltip.style.display = 'none';
        highlightMarker.visible = false;
      }
    }
  }

  function onPointerDown(event) {
    // 1. FIX: Ignore clicks on the GUI panel entirely
    if (gui.domElement.contains(event.target)) {
      return;
    }

    raycaster.setFromCamera(mouse, camera);

    // Handle annotation drawing first
    if (annotationState === 'placing_corner_1' || annotationState === 'placing_corner_2') {
      const intersects = raycaster.intersectObject(pointCloud);
      if (intersects.length > 0) {
          const intersectionPoint = intersects[0].point;

          if (annotationState === 'placing_corner_1') {
            corner1.copy(intersectionPoint);
            const tempBox = new THREE.Box3().setFromPoints([corner1, corner1]);
            currentBBoxHelper = new THREE.Box3Helper(tempBox, 0xffff00); // Yellow color
            scene.add(currentBBoxHelper);
            annotationState = 'placing_corner_2';
            instructions.innerHTML = 'Click to place the second corner.';
          } else if (annotationState === 'placing_corner_2') {
            const corner2 = intersectionPoint;
            const finalBox = new THREE.Box3().setFromPoints([corner1, corner2]);
            const description = prompt("Enter a description for this annotation:", "");

            if (description !== null) {
              createAnnotation(finalBox, description);
            }

            // Clean up temporary helper
            scene.remove(currentBBoxHelper);
            currentBBoxHelper.geometry.dispose();
            currentBBoxHelper.material.dispose();
            currentBBoxHelper = null;
            
            // Reset state
            annotationState = 'idle';
            controls.enabled = true;
            instructions.style.display = 'none';
          }
      }
      return; // Exit after handling annotation drawing
    }

    // 2. SELECTION IMPROVEMENT: If not drawing, handle selection by clicking inside box
    const intersects = raycaster.intersectObjects(annotationHitboxes);
    if (intersects.length > 0) {
      const selectedBoxAnnotation = intersects[0].object.userData.annotation;
      selectAnnotation(selectedBoxAnnotation);
    } else {
      // Clicked on empty space, deselect
      selectAnnotation(null);
    }
  }

  function onKeyDown(event) {
    // FIX: Ignore key events if user is interacting with the GUI
    if (gui.domElement.contains(document.activeElement)) {
      return;
    }
    if ((event.key === 'Delete' || event.key === 'Backspace') && selectedAnnotation) {
      deleteSelectedAnnotation();
    }
  }

  function createAnnotation(box, description) {
    const newId = nextAnnotationId++;
    const finalBoxHelper = new THREE.Box3Helper(box, 0x00ff00);
    scene.add(finalBoxHelper);
    const hitboxMesh = createHitbox(box);
    const labelElement = createLabel(box, description);
    
    const newAnnotation = {
      id: newId,
      box: box,
      description: description,
      helper: finalBoxHelper,
      labelElement: labelElement,
      selectionMesh: hitboxMesh,
      mapFeature: null,
    };

    const c1 = toLonLat(box.min.x, box.min.y);
    const c2 = toLonLat(box.max.x, box.max.y);
    if (c1 && c2) {
      const minLon = Math.min(c1.lon, c2.lon);
      const minLat = Math.min(c1.lat, c2.lat);
      const maxLon = Math.max(c1.lon, c2.lon);
      const maxLat = Math.max(c1.lat, c2.lat);
      newAnnotation.mapFeature = createGeoJsonPolygon(minLon, minLat, maxLon, maxLat, newId, { description });
    }

    annotations.push(newAnnotation);
    selectAnnotation(newAnnotation);
    updateMapAnnotations();
  }

  function deleteSelectedAnnotation() {
    if (!selectedAnnotation) return;

    // Remove from 3D scene
    scene.remove(selectedAnnotation.helper);
    scene.remove(selectedAnnotation.selectionMesh);
    labelsContainer.removeChild(selectedAnnotation.labelElement);
    
    // Remove from map (by removing from source data and updating)
    if (selectedAnnotation.mapFeature) {
      map.setFeatureState({ source: 'annotations', id: selectedAnnotation.id }, { selected: false });
    }

    // Remove from our master list
    const index = annotations.findIndex(a => a.id === selectedAnnotation.id);
    if (index > -1) {
      annotations.splice(index, 1);
    }
    
    selectAnnotation(null); // Deselect
    updateMapAnnotations(); // Re-render map annotations
  }

  function selectAnnotation(annotation) {
    // Deselect previous
    if (selectedAnnotation) {
      selectedAnnotation.helper.material.color.set(0x00ff00); // Back to green
      if (selectedAnnotation.mapFeature) {
        map.setFeatureState({ source: 'annotations', id: selectedAnnotation.id }, { selected: false });
      }
    }

    selectedAnnotation = annotation;

    // Select new one
    if (selectedAnnotation) {
      selectedAnnotation.helper.material.color.set(0xff00ff); // Magenta
      editFolder.children.forEach(c => c.destroy());
      const descriptionController = editFolder.add(selectedAnnotation, 'description').name('Description');
      descriptionController.onChange(val => {
        selectedAnnotation.labelElement.textContent = val;
        if(selectedAnnotation.mapFeature) {
          selectedAnnotation.mapFeature.properties.description = val;
          updateMapAnnotations();
        }
      });
      editFolder.show();
      if (selectedAnnotation.mapFeature) {
        map.setFeatureState({ source: 'annotations', id: selectedAnnotation.id }, { selected: true });
      }
    } else {
      editFolder.hide();
    }
  }

  function saveAnnotations() {
    if (annotations.length === 0) {
      alert("There are no annotations on the screen to save.");
      return;
    }

    const serializableAnnotations = annotations.map(anno => ({
      description: anno.description,
      box_min: anno.box.min,
      box_max: anno.box.max,
    }));

    const jsonString = JSON.stringify(serializableAnnotations, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;

    // Create a timestamped filename
    const now = new Date();
    const timestamp = now.toISOString().replace(/[:.]/g, '-'); // YYYY-MM-DDTHH-mm-ss-SSSZ
    a.download = `annotations_${timestamp}.json`;

    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function updateMapAnnotations() {
    const source = map.getSource('annotations');
    if (source) {
      const features = annotations.map(a => a.mapFeature).filter(f => f);
      source.setData({ type: 'FeatureCollection', features: features });
    }
  }

  // --- Event Listeners & Render Loop ---
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('keydown', onKeyDown);
  
  const tempVec = new THREE.Vector3();
  function animate() {
    requestAnimationFrame(animate);
    controls.update();

    annotations.forEach(anno => {
      anno.box.getCenter(tempVec);
      tempVec.project(camera);
      const x = (tempVec.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
      const y = (tempVec.y * -0.5 + 0.5) * renderer.domElement.clientHeight;
      anno.labelElement.style.transform = `translate(-50%, -120%) translate(${x}px, ${y}px)`;
    });

    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html> 